### AUDIT BUNDLE 2026-01-23 11:58:47

================================================================================
FILE: scripts/live_auto_trader.py
================================================================================
#!/usr/bin/env python3
"""
Brooks Auto Trader - AUTOMATIC ORDER PLACEMENT
âš ï¸ USE WITH EXTREME CAUTION - ONLY ON DEMO FIRST!
"""

import argparse
import logging
import os
import sys
import time

import MetaTrader5 as mt5
import pandas as pd
import yaml

sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from execution.ftmo_guardian import FTMOGuardian, FTMORules
from execution.ftmo_state import FTMOState
from execution.guardrails import Guardrails
from execution.risk_manager import RiskManager
from execution.trade_executor import execute_trade_ftmo_safe
from strategies.config import StrategyConfig
from strategies.context import Trend, infer_trend_m15
from strategies.h2l2 import Side, plan_next_open_trade
from strategies.regime import should_trade_today
from utils.mt5_client import Mt5Client
from utils.mt5_data import RatesRequest, fetch_rates

logger = logging.getLogger(__name__)


def auto_trade_loop(
    strategy_config: StrategyConfig,
    ftmo_config: dict,
    check_interval: int = 60,
):
    """
    Main auto-trading loop - PLACES REAL ORDERS!
    """
    # Initialize MT5
    client = Mt5Client(mt5_module=mt5)
    if not client.initialize():
        logger.error("âŒ MT5 init failed")
        return

    # Get initial equity
    acc_info = mt5.account_info()
    if not acc_info:
        logger.error("âŒ Failed to get account info")
        client.shutdown()
        return

    initial_equity = float(acc_info.equity)
    running_max_equity = initial_equity

    # CRITICAL: Verify DEMO account
    acc_server = acc_info.server.lower()
    is_demo = "demo" in acc_server

    if not is_demo:
        logger.error("ðŸš¨ LIVE ACCOUNT DETECTED - ABORTING FOR SAFETY!")
        logger.error(f"   Server: {acc_info.server}")
        logger.error("   This script should ONLY run on demo accounts!")
        client.shutdown()
        return

    logger.info("âœ… DEMO account verified: %s", acc_info.server)

    # Initialize FTMO protection
    if ftmo_config.get("enabled", False):
        account_size = ftmo_config.get("account_size", 10000)
        rules = FTMORules(
            account_type=FTMORules.for_10k_challenge().account_type,
            initial_balance=account_size,
            max_daily_loss_pct=ftmo_config.get("max_daily_loss_pct", 5.0),
            max_total_loss_pct=ftmo_config.get("max_total_loss_pct", 10.0),
            profit_target_pct=ftmo_config.get("profit_target_pct", 10.0),
            daily_loss_buffer_pct=ftmo_config.get("daily_buffer_pct", 1.0),
            total_loss_buffer_pct=ftmo_config.get("total_buffer_pct", 2.0),
        )
        ftmo_guardian = FTMOGuardian(rules=rules)
        ftmo_state = FTMOState.initialize(initial_equity, day_tz="America/New_York")
        logger.info("âœ… FTMO Protection: ENABLED")
    else:
        ftmo_guardian = None
        ftmo_state = None
        logger.warning("âš ï¸ FTMO Protection: DISABLED - HIGH RISK!")

    # Initialize components
    risk_manager = RiskManager()
    spec = client.get_symbol_specification(strategy_config.symbol)

    if not spec:
        logger.error("âŒ Failed to get symbol spec for %s", strategy_config.symbol)
        client.shutdown()
        return

    logger.info("=" * 80)
    logger.info("ðŸ¤– AUTO TRADER STARTED - ORDERS WILL BE PLACED AUTOMATICALLY")
    logger.info("=" * 80)
    logger.info(f"Account: {acc_info.login} ({acc_info.server})")
    logger.info(f"Balance: ${acc_info.balance:,.2f}")
    logger.info(f"Symbol: {strategy_config.symbol}")
    logger.info(f"Risk per trade: {strategy_config.risk_pct}%")
    logger.info(f"Max trades/day: {strategy_config.guardrails.max_trades_per_day}")
    logger.info(f"Check interval: {check_interval}s")
    logger.info("=" * 80)
    logger.warning("âš ï¸ AUTOMATIC ORDER PLACEMENT IS ACTIVE!")
    logger.info("=" * 80)

    iteration = 0
    last_ftmo_log = time.time()

    try:
        while True:
            iteration += 1

            # Emergency stop check
            if os.path.exists("STOP.txt"):
                logger.error("ðŸ›‘ EMERGENCY STOP DETECTED - HALTING")
                break

            # Update equity
            acc_info = mt5.account_info()
            if acc_info:
                equity_now = float(acc_info.equity)
                running_max_equity = max(running_max_equity, equity_now)
            else:
                equity_now = running_max_equity
                logger.warning("âš ï¸ Could not fetch account info, using cached equity")

            # Update FTMO state
            if ftmo_state:
                now_utc = pd.Timestamp.now(tz="UTC")
                day_reset = ftmo_state.update(equity_now, now_utc)
                if day_reset:
                    logger.info("ðŸ”„ New trading day - limits reset")

                # Log FTMO status every 5 minutes
                if time.time() - last_ftmo_log >= 300:
                    daily_pnl = ftmo_state.get_daily_pnl(equity_now)
                    total_pnl = ftmo_state.get_total_pnl(equity_now)

                    logger.info("=" * 80)
                    logger.info("ðŸ’¼ FTMO STATUS")
                    logger.info("=" * 80)
                    logger.info(f"Equity: ${equity_now:,.2f}")
                    logger.info(f"Daily P&L: ${daily_pnl:+,.2f}")
                    logger.info(f"Total P&L: ${total_pnl:+,.2f}")
                    logger.info(f"Trading Days: {ftmo_state.trading_days}")

                    if ftmo_guardian:
                        max_risk = ftmo_guardian.get_max_allowed_risk(equity_now, daily_pnl)
                        logger.info(f"Max Risk Headroom: ${max_risk:,.2f}")

                    logger.info("=" * 80)
                    last_ftmo_log = time.time()

            logger.info(f"[Iter {iteration}] Checking for signals...")

            # Fetch data
            try:
                req_m15 = RatesRequest(strategy_config.symbol, mt5.TIMEFRAME_M15, 300)
                req_m5 = RatesRequest(strategy_config.symbol, mt5.TIMEFRAME_M5, 500)

                m15_data = fetch_rates(mt5, req_m15)
                m5_data = fetch_rates(mt5, req_m5)
            except Exception as e:
                logger.error(f"âŒ Data fetch failed: {e}")
                time.sleep(check_interval)
                continue

            if m15_data.empty or m5_data.empty:
                logger.warning("âš ï¸ Empty data - skipping")
                time.sleep(check_interval)
                continue

            # Regime filter
            if strategy_config.regime_filter:
                ok, reason = should_trade_today(m15_data, strategy_config.regime_params)
                if not ok:
                    logger.info(f"â›” Regime filter: {reason}")
                    time.sleep(check_interval)
                    continue
                logger.info(f"âœ… Regime: {reason}")

            # Trend detection
            trend, metrics = infer_trend_m15(m15_data, strategy_config.trend_params)
            logger.info(f"ðŸ“Š Trend: {trend.value if hasattr(trend, 'value') else str(trend)}")

            if trend not in (Trend.BULL, Trend.BEAR):
                logger.info("â¸ï¸ No clear trend - waiting")
                time.sleep(check_interval)
                continue

            side = Side.LONG if trend == Trend.BULL else Side.SHORT

            # Plan trade
            planned = plan_next_open_trade(
                m5_data,
                side,
                spec,
                strategy_config.h2l2_params,
                timeframe_minutes=5,
            )

            if not planned:
                logger.info("â¸ï¸ No setup found")
                time.sleep(check_interval)
                continue

            logger.info("=" * 80)
            logger.info("ðŸŽ¯ SETUP DETECTED!")
            logger.info("=" * 80)
            logger.info(f"Reason: {planned.reason}")
            logger.info(f"Side: {planned.side.value}")
            logger.info(f"Entry: {planned.entry:.2f}")
            logger.info(f"Stop: {planned.stop:.2f}")
            logger.info(f"Target: {planned.tp:.2f}")
            logger.info("=" * 80)

            # ===================================================
            # ðŸš¨ EXECUTE TRADE AUTOMATICALLY (ATOMIC + FTMO-SAFE)
            # ===================================================
            logger.info("ðŸš€ Executing trade...")

            result = execute_trade_ftmo_safe(
                planned_trade=planned,
                equity_now=equity_now,
                ftmo_state=ftmo_state,
                ftmo_guardian=ftmo_guardian,
                guardrails=strategy_config.guardrails,
                risk_manager=risk_manager,
                spec=spec,
                requested_risk_pct=strategy_config.risk_pct,
                mt5_module=mt5,
            )

            if result.success:
                logger.info("=" * 80)
                logger.info("âœ… âœ… âœ… TRADE EXECUTED SUCCESSFULLY âœ… âœ… âœ…")
                logger.info("=" * 80)
                logger.info(f"Ticket: {result.ticket}")
                logger.info(f"Side: {planned.side.value}")
                logger.info(f"Entry: {result.filled_price:.2f}")
                logger.info(f"Stop: {planned.stop:.2f}")
                logger.info(f"Target: {planned.tp:.2f}")
                logger.info(f"Lots: {result.filled_lots:.2f}")
                logger.info(f"Risk: ${result.actual_risk_usd:.2f}")
                logger.info("=" * 80)

                # Increment trading days counter
                if ftmo_state:
                    ftmo_state.increment_trading_day()

            else:
                logger.warning("=" * 80)
                logger.warning("â›” TRADE BLOCKED")
                logger.warning("=" * 80)
                logger.warning(f"Reason: {result.reason}")
                if result.block_stage:
                    logger.warning(f"Stage: {result.block_stage}")
                logger.warning("=" * 80)

            # Wait before next check
            logger.info(f"ðŸ’¤ Sleeping {check_interval}s until next check...")
            time.sleep(check_interval)

    except KeyboardInterrupt:
        logger.info("â›” Auto trader stopped by user (Ctrl+C)")
    except Exception as e:
        logger.error(f"âŒ Auto trader crashed: {e}", exc_info=True)
    finally:
        logger.info("ðŸ”Œ Shutting down MT5 connection...")
        client.shutdown()
        logger.info("âœ… Auto trader stopped cleanly")


def main() -> int:
    parser = argparse.ArgumentParser(
        description="Brooks Auto Trader - AUTOMATIC ORDER PLACEMENT",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
âš ï¸  WARNING: This script places REAL orders automatically!

    ONLY use on DEMO accounts initially!

    Emergency stop: Create STOP.txt in project root
""",
    )
    parser.add_argument("--strategy", default="config/strategies/us500_sniper.yaml")
    parser.add_argument("--env", default="config/environments/production.yaml")
    parser.add_argument("--interval", type=int, default=60, help="Check interval in seconds")
    parser.add_argument("--log-level", default="INFO", choices=["DEBUG", "INFO", "WARNING"])

    args = parser.parse_args()

    logging.basicConfig(
        level=getattr(logging, args.log_level.upper()),
        format="%(asctime)s [%(levelname)s] %(message)s",
        handlers=[
            logging.StreamHandler(),
            logging.FileHandler(
                f"logs/auto_trader_{pd.Timestamp.now().strftime('%Y%m%d_%H%M%S')}.log"
            ),
        ],
    )

    # Load configs
    logger.info("ðŸ“‹ Loading configuration...")
    strategy_config = StrategyConfig.load(args.strategy)

    with open(args.env, "r") as f:
        env_config = yaml.safe_load(f)
    ftmo_config = env_config.get("ftmo", {})

    # Display configuration
    print("\n" + "=" * 80)
    print("  ðŸ“‹ CONFIGURATION LOADED")
    print("=" * 80)
    print(f"Strategy: {args.strategy}")
    print(f"Symbol: {strategy_config.symbol}")
    print(f"Risk per trade: {strategy_config.risk_pct}%")
    print(f"Max trades/day: {strategy_config.guardrails.max_trades_per_day}")
    print(f"Regime filter: {'ON' if strategy_config.regime_filter else 'OFF'}")
    print(f"FTMO Protection: {'ENABLED' if ftmo_config.get('enabled') else 'DISABLED'}")
    print("=" * 80)

    # WARNING prompt
    print("\n" + "âš ï¸" * 40)
    print("  âš ï¸  AUTOMATIC ORDER PLACEMENT IS ABOUT TO START  âš ï¸")
    print("âš ï¸" * 40)
    print("\nâš ï¸ ORDERS WILL BE PLACED AUTOMATICALLY WITHOUT CONFIRMATION!")
    print("âš ï¸ Ensure you are on a DEMO account!")
    print("\nðŸ›‘ To stop trading, either:")
    print("   1. Press Ctrl+C")
    print("   2. Create STOP.txt in project root")
    print("\nâ° Starting in 10 seconds...")
    print("   Press Ctrl+C NOW to abort!\n")

    try:
        for i in range(10, 0, -1):
            print(f"   {i}...", end="", flush=True)
            time.sleep(1)
        print(" GO!")
    except KeyboardInterrupt:
        print("\n\nâœ… Aborted by user")
        return 0

    print("\nðŸš€ Starting auto trader...\n")

    auto_trade_loop(strategy_config, ftmo_config, args.interval)
    return 0


if __name__ == "__main__":
    sys.exit(main())

================================================================================
FILE: execution/trade_gate.py
================================================================================
# execution/trade_gate.py
"""
FTMO Trade Gate - Central Kill-Switch

Single choke point for all trade placement.
Enforces FTMO limits BEFORE order execution.

Flow:
1. Check FTMO Guardian can_trade()
2. Cap risk to FTMO headroom
3. Return (allowed, reason, capped_risk)

Non-negotiable: NO trade bypasses this gate.
"""

from __future__ import annotations

import logging
from dataclasses import dataclass

from execution.ftmo_guardian import FTMOGuardian
from execution.ftmo_state import FTMOState

logger = logging.getLogger(__name__)


@dataclass
class TradeGateResult:
    """Result from trade gate check"""

    allowed: bool
    reason: str
    capped_risk_usd: float

    @property
    def blocked(self) -> bool:
        return not self.allowed


def check_ftmo_trade_gate(
    *,
    equity_now: float,
    ftmo_state: FTMOState,
    ftmo_guardian: FTMOGuardian,
    requested_risk_usd: float,
    min_risk_threshold: float = 10.0,
) -> TradeGateResult:
    """
    FTMO Trade Gate - Check if trade is allowed and cap risk.

    This is the SINGLE CENTRAL GATE for all trade placement.
    Must be called BEFORE order placement, not just in planning.

    Args:
        equity_now: Current account equity (from MT5)
        ftmo_state: FTMO state tracker
        ftmo_guardian: FTMO rule enforcer
        requested_risk_usd: Requested risk in USD from strategy
        min_risk_threshold: Minimum risk USD to proceed (avoid noise trades)

    Returns:
        TradeGateResult with (allowed, reason, capped_risk_usd)

    Example:
        result = check_ftmo_trade_gate(
            equity_now=10500.0,
            ftmo_state=state,
            ftmo_guardian=guardian,
            requested_risk_usd=100.0,
        )

        if result.blocked:
            logger.warning("Trade blocked: %s", result.reason)
            return

        # Use result.capped_risk_usd for position sizing
        risk_pct = 100.0 * (result.capped_risk_usd / equity_now)
    """
    # Get current FTMO state
    daily_pnl = ftmo_state.get_daily_pnl(equity_now)

    # Step 1: Check if FTMO Guardian allows trade
    allowed, reason = ftmo_guardian.can_trade(
        current_balance=equity_now,  # Use equity, not balance!
        daily_pnl=daily_pnl,
        open_risk=requested_risk_usd,
    )

    if not allowed:
        logger.warning("â›” FTMO GATE BLOCKED: %s", reason)
        return TradeGateResult(
            allowed=False,
            reason=reason,
            capped_risk_usd=0.0,
        )

    # Step 2: Cap risk to FTMO headroom
    max_allowed_risk = ftmo_guardian.get_max_allowed_risk(equity_now, daily_pnl)
    capped_risk = min(requested_risk_usd, max_allowed_risk)

    # Step 3: Check minimum threshold
    if capped_risk < min_risk_threshold:
        logger.warning(
            "â›” FTMO GATE BLOCKED: Risk too small (%.2f < %.2f threshold)",
            capped_risk,
            min_risk_threshold,
        )
        return TradeGateResult(
            allowed=False,
            reason=f"FTMO headroom too small (${capped_risk:.2f} < ${min_risk_threshold:.2f})",
            capped_risk_usd=0.0,
        )

    # Trade allowed!
    if capped_risk < requested_risk_usd:
        logger.info(
            "âœ… FTMO GATE: Trade allowed, risk capped: $%.2f â†’ $%.2f (headroom: $%.2f)",
            requested_risk_usd,
            capped_risk,
            max_allowed_risk,
        )
    else:
        logger.info(
            "âœ… FTMO GATE: Trade allowed, risk=$%.2f (headroom: $%.2f)",
            capped_risk,
            max_allowed_risk,
        )

    return TradeGateResult(
        allowed=True,
        reason="ALLOWED",
        capped_risk_usd=capped_risk,
    )


def convert_risk_to_pct(risk_usd: float, equity: float) -> float:
    """
    Convert USD risk to percentage of equity.

    Args:
        risk_usd: Risk in USD
        equity: Current account equity

    Returns:
        Risk as percentage (e.g., 1.0 for 1%)
    """
    if equity <= 0:
        raise ValueError("Equity must be > 0")
    return 100.0 * (risk_usd / equity)


def log_ftmo_status(
    equity_now: float,
    ftmo_state: FTMOState,
    ftmo_guardian: FTMOGuardian,
    running_max_equity: float,
) -> None:
    """
    Log FTMO status for monitoring (console/telegram).
    Should be called periodically in live loop.

    Args:
        equity_now: Current equity
        ftmo_state: FTMO state tracker
        ftmo_guardian: FTMO rule enforcer
        running_max_equity: Highest equity reached
    """
    status_summary = ftmo_state.get_status_summary(equity_now, running_max_equity)
    daily_pnl = status_summary["daily_pnl_usd"]

    # Get guardian account status
    account_status = ftmo_guardian.get_account_status(
        current_balance=equity_now,
        daily_pnl=daily_pnl,
        trading_days=status_summary["trading_days"],
    )

    # Get headroom
    max_risk = ftmo_guardian.get_max_allowed_risk(equity_now, daily_pnl)

    print("\n" + "=" * 70)
    print("  ðŸ’¼ FTMO STATUS")
    print("=" * 70)
    print(f"  Equity: ${equity_now:,.2f}")
    print(f"  Daily P&L: ${daily_pnl:+,.2f} / ${ftmo_guardian.max_daily_loss_usd:,.2f}")
    print(
        f"  Total Profit: ${account_status['total_profit']:+,.2f} / Target: ${account_status['profit_target']:,.2f}"
    )
    print(
        f"  Total DD: ${account_status['total_drawdown']:,.2f} / ${ftmo_guardian.max_total_loss_usd:,.2f}"
    )
    print(f"  Health: {account_status['health']}")
    print(
        f"  Trading Days: {status_summary['trading_days']} / {ftmo_guardian.rules.min_trading_days}"
    )
    print(f"  Max Risk Headroom: ${max_risk:,.2f}")
    print("=" * 70)

================================================================================
FILE: execution/ftmo_guardian.py
================================================================================
# execution/ftmo_guardian.py
"""
FTMO Challenge Rule Enforcer
Prevents violations that would fail the challenge
"""

from __future__ import annotations

import logging
from dataclasses import dataclass
from enum import Enum

logger = logging.getLogger(__name__)


class FTMOAccountType(Enum):
    """FTMO account types with different rules"""

    CHALLENGE_10K = "10k"
    CHALLENGE_25K = "25k"
    CHALLENGE_50K = "50k"
    CHALLENGE_100K = "100k"
    CHALLENGE_200K = "200k"
    VERIFICATION = "verification"
    FUNDED = "funded"


@dataclass
class FTMORules:
    """
    FTMO Challenge Rules (as of 2026)

    Key Rules:
    1. Max Daily Loss: 5% of initial balance
    2. Max Total Drawdown: 10% of initial balance
    3. Profit Target: 10% for Challenge, 5% for Verification
    4. Minimum Trading Days: 4 days (at least 1 trade per day)
    5. No weekend holding (optional but recommended)
    6. No news trading in first 2 minutes
    """

    account_type: FTMOAccountType
    initial_balance: float

    # Loss limits (STRICT - account closes if breached!)
    max_daily_loss_pct: float = 5.0  # 5% max daily loss
    max_total_loss_pct: float = 10.0  # 10% max total drawdown

    # Profit targets
    profit_target_pct: float = 10.0  # 10% for Challenge, 5% for Verification

    # Trading constraints
    min_trading_days: int = 4
    max_lot_size: float = 5.0  # Adjust based on account size

    # Conservative buffers (stop BEFORE hitting limits)
    daily_loss_buffer_pct: float = 1.0  # Stop at 4% instead of 5%
    total_loss_buffer_pct: float = 2.0  # Stop at 8% instead of 10%

    @classmethod
    def for_10k_challenge(cls) -> FTMORules:
        """Standard 10k FTMO Challenge rules"""
        return cls(
            account_type=FTMOAccountType.CHALLENGE_10K,
            initial_balance=10000.0,
            max_daily_loss_pct=5.0,
            max_total_loss_pct=10.0,
            profit_target_pct=10.0,
            daily_loss_buffer_pct=1.0,  # Stop at 4% daily
            total_loss_buffer_pct=2.0,  # Stop at 8% total
        )

    @classmethod
    def for_verification(cls, balance: float) -> FTMORules:
        """FTMO Verification phase rules (after passing Challenge)"""
        return cls(
            account_type=FTMOAccountType.VERIFICATION,
            initial_balance=balance,
            max_daily_loss_pct=5.0,
            max_total_loss_pct=10.0,
            profit_target_pct=5.0,  # Lower target for Verification
            daily_loss_buffer_pct=1.0,
            total_loss_buffer_pct=2.0,
        )


class FTMOGuardian:
    """
    Enforces FTMO rules and prevents account violations

    Usage:
        guardian = FTMOGuardian(rules=FTMORules.for_10k_challenge())

        # Before taking trade
        can_trade, reason = guardian.can_trade(
            current_balance=9800,
            daily_pnl=-150,
            open_risk=50
        )

        if not can_trade:
            print(f"TRADE BLOCKED: {reason}")
    """

    def __init__(self, rules: FTMORules):
        self.rules = rules
        self.initial_balance = rules.initial_balance

        # Calculate absolute limits
        self.max_daily_loss_usd = rules.initial_balance * rules.max_daily_loss_pct / 100
        self.max_total_loss_usd = rules.initial_balance * rules.max_total_loss_pct / 100

        # Calculate safe buffers (stop BEFORE limits)
        self.safe_daily_loss_usd = (
            rules.initial_balance * (rules.max_daily_loss_pct - rules.daily_loss_buffer_pct) / 100
        )
        self.safe_total_loss_usd = (
            rules.initial_balance * (rules.max_total_loss_pct - rules.total_loss_buffer_pct) / 100
        )

        logger.info("FTMO Guardian initialized:")
        logger.info(f"  Account Type: {rules.account_type.value}")
        logger.info(f"  Initial Balance: ${rules.initial_balance:,.2f}")
        logger.info(f"  Max Daily Loss: ${self.max_daily_loss_usd:,.2f} (HARD LIMIT)")
        logger.info(f"  Safe Daily Loss: ${self.safe_daily_loss_usd:,.2f} (with buffer)")
        logger.info(f"  Max Total Loss: ${self.max_total_loss_usd:,.2f} (HARD LIMIT)")
        logger.info(f"  Safe Total Loss: ${self.safe_total_loss_usd:,.2f} (with buffer)")

    def can_trade(
        self,
        current_balance: float,
        daily_pnl: float,
        open_risk: float = 0.0,
        check_time: bool = True,
    ) -> tuple[bool, str]:
        """
        Check if trading is allowed

        Args:
            current_balance: Current account balance
            daily_pnl: Today's P&L so far (negative = loss)
            open_risk: Risk of proposed trade in USD
            check_time: Check for news/weekend restrictions

        Returns:
            (can_trade: bool, reason: str)
        """
        # 1. Check Daily Loss Limit
        projected_daily_loss = abs(min(daily_pnl, 0)) + open_risk

        if projected_daily_loss > self.safe_daily_loss_usd:
            return False, (
                f"DAILY LOSS LIMIT APPROACHING: "
                f"${projected_daily_loss:.2f} would exceed safe limit "
                f"(${self.safe_daily_loss_usd:.2f}). "
                f"STOP TRADING TODAY!"
            )

        # 2. Check Total Drawdown Limit
        total_drawdown = self.initial_balance - current_balance
        projected_total_loss = total_drawdown + open_risk

        if projected_total_loss > self.safe_total_loss_usd:
            return False, (
                f"TOTAL DRAWDOWN LIMIT APPROACHING: "
                f"${projected_total_loss:.2f} would exceed safe limit "
                f"(${self.safe_total_loss_usd:.2f}). "
                f"ACCOUNT IN DANGER!"
            )

        # 3. Check if account already breached HARD limits (should never happen)
        if abs(min(daily_pnl, 0)) >= self.max_daily_loss_usd:
            return False, (
                f"â›” CRITICAL: DAILY LOSS HARD LIMIT BREACHED! "
                f"${abs(daily_pnl):.2f} >= ${self.max_daily_loss_usd:.2f}. "
                f"STOP ALL TRADING IMMEDIATELY! ACCOUNT MAY BE CLOSED!"
            )

        if total_drawdown >= self.max_total_loss_usd:
            return False, (
                f"â›” CRITICAL: TOTAL DRAWDOWN HARD LIMIT BREACHED! "
                f"${total_drawdown:.2f} >= ${self.max_total_loss_usd:.2f}. "
                f"STOP ALL TRADING IMMEDIATELY! ACCOUNT WILL BE CLOSED!"
            )

        # 4. Warning if getting close to limits
        daily_loss_pct = (projected_daily_loss / self.max_daily_loss_usd) * 100
        total_loss_pct = (projected_total_loss / self.max_total_loss_usd) * 100

        warnings = []
        if daily_loss_pct > 70:
            warnings.append(
                f"âš ï¸  Daily loss at {daily_loss_pct:.1f}% of limit "
                f"(${projected_daily_loss:.2f}/${self.max_daily_loss_usd:.2f})"
            )

        if total_loss_pct > 70:
            warnings.append(
                f"âš ï¸  Total drawdown at {total_loss_pct:.1f}% of limit "
                f"(${projected_total_loss:.2f}/${self.max_total_loss_usd:.2f})"
            )

        if warnings:
            warning_msg = " | ".join(warnings)
            logger.warning(warning_msg)

        # All checks passed
        return True, "OK - All FTMO rules satisfied"

    def get_max_allowed_risk(self, current_balance: float, daily_pnl: float) -> float:
        """
        Calculate maximum allowed risk for next trade

        Args:
            current_balance: Current account balance
            daily_pnl: Today's P&L so far

        Returns:
            Max risk in USD
        """
        # Calculate headroom for both limits
        daily_headroom = self.safe_daily_loss_usd - abs(min(daily_pnl, 0))

        total_drawdown = self.initial_balance - current_balance
        total_headroom = self.safe_total_loss_usd - total_drawdown

        # Take the more restrictive limit
        max_risk = min(daily_headroom, total_headroom)

        # Never allow negative risk
        return max(0, max_risk)

    def get_account_status(
        self, current_balance: float, daily_pnl: float, total_trades: int = 0, trading_days: int = 0
    ) -> dict:
        """
        Get comprehensive account status report

        Returns:
            Dict with account health metrics
        """
        total_drawdown = self.initial_balance - current_balance
        daily_loss = abs(min(daily_pnl, 0))

        # Calculate percentages of limits used
        daily_loss_pct = (daily_loss / self.max_daily_loss_usd) * 100
        total_loss_pct = (total_drawdown / self.max_total_loss_usd) * 100

        # Calculate profit progress
        total_profit = current_balance - self.initial_balance
        profit_target_usd = self.initial_balance * self.rules.profit_target_pct / 100
        profit_progress_pct = (
            (total_profit / profit_target_usd) * 100 if profit_target_usd > 0 else 0
        )

        # Determine account health
        if daily_loss_pct > 90 or total_loss_pct > 90:
            health = "CRITICAL"
        elif daily_loss_pct > 70 or total_loss_pct > 70:
            health = "WARNING"
        elif daily_loss_pct > 50 or total_loss_pct > 50:
            health = "CAUTION"
        else:
            health = "HEALTHY"

        return {
            "health": health,
            "current_balance": current_balance,
            "initial_balance": self.initial_balance,
            "total_profit": total_profit,
            "total_drawdown": total_drawdown,
            "daily_pnl": daily_pnl,
            "daily_loss": daily_loss,
            "daily_loss_pct": daily_loss_pct,
            "daily_loss_limit": self.max_daily_loss_usd,
            "total_loss_pct": total_loss_pct,
            "total_loss_limit": self.max_total_loss_usd,
            "profit_target": profit_target_usd,
            "profit_progress_pct": profit_progress_pct,
            "total_trades": total_trades,
            "trading_days": trading_days,
            "min_trading_days": self.rules.min_trading_days,
        }

    def print_status(self, status: dict) -> None:
        """Print formatted account status"""
        print("\n" + "=" * 60)
        print(f"  ðŸ“Š FTMO ACCOUNT STATUS: {status['health']}")
        print("=" * 60)
        print("\nðŸ’° BALANCE:")
        print(f"  Current  : ${status['current_balance']:,.2f}")
        print(f"  Initial  : ${status['initial_balance']:,.2f}")
        print(f"  Profit   : ${status['total_profit']:+,.2f}")

        print("\nðŸ“‰ DAILY RISK:")
        print(f"  Today P&L: ${status['daily_pnl']:+,.2f}")
        print(f"  Daily Loss: ${status['daily_loss']:,.2f} / ${status['daily_loss_limit']:,.2f}")
        print(f"  Usage    : {status['daily_loss_pct']:.1f}% of limit")

        print("\nðŸ“Š TOTAL DRAWDOWN:")
        print(f"  Drawdown : ${status['total_drawdown']:,.2f} / ${status['total_loss_limit']:,.2f}")
        print(f"  Usage    : {status['total_loss_pct']:.1f}% of limit")

        print("\nðŸŽ¯ PROFIT TARGET:")
        print(f"  Target   : ${status['profit_target']:,.2f}")
        print(f"  Progress : {status['profit_progress_pct']:.1f}%")

        print("\nðŸ“… TRADING ACTIVITY:")
        print(f"  Trades   : {status['total_trades']}")
        print(f"  Days     : {status['trading_days']} / {status['min_trading_days']} minimum")

        print("\n" + "=" * 60 + "\n")


# Example usage
if __name__ == "__main__":
    # Test FTMO Guardian
    print("Testing FTMO Guardian...\n")

    # 10k Challenge
    rules = FTMORules.for_10k_challenge()
    guardian = FTMOGuardian(rules)

    # Scenario 1: Normal trading
    print("\nðŸ“‹ SCENARIO 1: Normal trading day")
    can_trade, reason = guardian.can_trade(
        current_balance=10050,  # Up $50
        daily_pnl=50,  # Profit today
        open_risk=50,  # Next trade risk
    )
    print(f"Can trade: {can_trade}")
    print(f"Reason: {reason}")

    # Scenario 2: After some losses
    print("\nðŸ“‹ SCENARIO 2: After -$300 loss today")
    can_trade, reason = guardian.can_trade(current_balance=9700, daily_pnl=-300, open_risk=50)
    print(f"Can trade: {can_trade}")
    print(f"Reason: {reason}")

    # Scenario 3: Approaching daily limit
    print("\nðŸ“‹ SCENARIO 3: Approaching daily limit (-$380)")
    can_trade, reason = guardian.can_trade(current_balance=9620, daily_pnl=-380, open_risk=50)
    print(f"Can trade: {can_trade}")
    print(f"Reason: {reason}")

    # Get account status
    print("\nðŸ“Š ACCOUNT STATUS:")
    status = guardian.get_account_status(
        current_balance=9620, daily_pnl=-380, total_trades=25, trading_days=5
    )
    guardian.print_status(status)

================================================================================
FILE: execution/ftmo_state.py
================================================================================
# execution/ftmo_state.py
"""
FTMO State Tracker - Equity-Based Daily/Total PnL

Tracks equity at challenge start and day boundaries (NY timezone).
Provides equity-based daily/total PnL for FTMO Guardian.

Key Features:
- Equity-based (not balance-based) to include open PnL
- NY timezone day reset (consistent with guardrails)
- Deterministic state tracking
- No persistence (in-memory for live session)
"""

from __future__ import annotations

import logging
from dataclasses import dataclass
from datetime import date

import pandas as pd

logger = logging.getLogger(__name__)


@dataclass
class FTMOState:
    """
    Tracks equity-based FTMO state.

    CRITICAL: Uses equity (balance + open PnL), not just balance.
    This matches FTMO MetriX behavior where open positions affect limits.
    """

    equity_start_of_challenge: float
    equity_start_of_day: float
    current_day: date | None
    day_tz: str = "America/New_York"
    trading_days: int = 0  # Count of days with trades

    @classmethod
    def initialize(cls, initial_equity: float, day_tz: str = "America/New_York") -> "FTMOState":
        """
        Initialize FTMO state at challenge start.

        Args:
            initial_equity: Account equity at challenge start (from MT5)
            day_tz: Timezone for day boundaries (must match guardrails)

        Returns:
            New FTMOState instance
        """
        logger.info("ðŸŽ¯ FTMO State initialized: equity=%.2f, tz=%s", initial_equity, day_tz)
        return cls(
            equity_start_of_challenge=initial_equity,
            equity_start_of_day=initial_equity,
            current_day=None,
            day_tz=day_tz,
            trading_days=0,
        )

    def update(self, equity_now: float, timestamp_utc: pd.Timestamp) -> bool:
        """
        Update state with current equity and time.
        Handles NY day reset automatically.

        Args:
            equity_now: Current account equity (from MT5)
            timestamp_utc: Current timestamp (UTC, tz-aware)

        Returns:
            True if day reset occurred, False otherwise
        """
        if timestamp_utc.tzinfo is None:
            raise ValueError("timestamp_utc must be tz-aware (UTC)")

        # Convert to NY day
        ny_day = timestamp_utc.tz_convert(self.day_tz).date()

        # Check for day reset
        if self.current_day is None:
            # First call - initialize but DON'T update equity_start_of_day
            # (it was set in __init__ with challenge start equity)
            self.current_day = ny_day
            logger.info(
                "ðŸ“… FTMO day initialized: %s, equity_start=%.2f", ny_day, self.equity_start_of_day
            )
            return False

        if ny_day != self.current_day:
            # Day boundary crossed - RESET
            old_day = self.current_day
            daily_pnl = equity_now - self.equity_start_of_day

            # Reset day state
            self.current_day = ny_day
            self.equity_start_of_day = equity_now

            logger.info(
                "ðŸ”„ FTMO day reset: %s â†’ %s, daily_pnl=$%.2f, new_equity_start=%.2f",
                old_day,
                ny_day,
                daily_pnl,
                equity_now,
            )
            return True

        # Same day - no changes to equity_start_of_day
        return False

    def get_daily_pnl(self, equity_now: float) -> float:
        """
        Get daily PnL in USD (equity-based).

        Args:
            equity_now: Current account equity

        Returns:
            Daily PnL in USD (can be negative)
        """
        return equity_now - self.equity_start_of_day

    def get_total_pnl(self, equity_now: float) -> float:
        """
        Get total PnL since challenge start in USD (equity-based).

        Args:
            equity_now: Current account equity

        Returns:
            Total PnL in USD (can be negative)
        """
        return equity_now - self.equity_start_of_challenge

    def get_total_drawdown(self, equity_now: float, running_max_equity: float) -> float:
        """
        Get total drawdown from running max equity.

        Args:
            equity_now: Current account equity
            running_max_equity: Highest equity reached during challenge

        Returns:
            Drawdown in USD (always <= 0)
        """
        return min(0.0, equity_now - running_max_equity)

    def increment_trading_day(self) -> None:
        """
        Increment trading days counter.
        Should be called when a trade is executed on a new day.
        """
        self.trading_days += 1
        logger.info("ðŸ“Š Trading days: %d", self.trading_days)

    def get_status_summary(self, equity_now: float, running_max_equity: float) -> dict:
        """
        Get complete status summary for logging/monitoring.

        Args:
            equity_now: Current account equity
            running_max_equity: Highest equity reached

        Returns:
            Dict with all FTMO metrics
        """
        daily_pnl = self.get_daily_pnl(equity_now)
        total_pnl = self.get_total_pnl(equity_now)
        total_dd = self.get_total_drawdown(equity_now, running_max_equity)

        return {
            "equity_now": equity_now,
            "equity_start_challenge": self.equity_start_of_challenge,
            "equity_start_day": self.equity_start_of_day,
            "daily_pnl_usd": daily_pnl,
            "total_pnl_usd": total_pnl,
            "total_dd_usd": total_dd,
            "current_day": str(self.current_day),
            "trading_days": self.trading_days,
        }

================================================================================
FILE: execution/risk_manager.py
================================================================================
# execution/risk_manager.py
from __future__ import annotations

import logging
from dataclasses import dataclass

from utils.symbol_spec import SymbolSpec

logger = logging.getLogger(__name__)


@dataclass(frozen=True)
class RiskParams:
    min_risk_pts: float = 1.0
    fees_usd: float = 0.0


class RiskManager:
    """
    Fixed Risk Manager - NOW COMPATIBLE WITH ALL CALLERS

    Accepts both old-style (spec=SymbolSpec) and new-style (kwargs) calls.
    """

    def __init__(self, params: RiskParams = None):
        self.params = params or RiskParams()

    def size_position(
        self,
        *,
        balance: float,
        entry: float,
        stop: float,
        risk_pct: float,
        spec: SymbolSpec = None,
        tick_size: float = None,
        contract_size: float = None,
        fees_usd: float = None,
        **_ignored,
    ) -> tuple[float, float]:
        """
        Universal sizing method - works with ANY caller.

        Args:
            balance: Account balance
            entry: Entry price
            stop: Stop loss price
            risk_pct: Risk as PERCENTAGE (e.g., 0.5 for 0.5%)
            spec: SymbolSpec object (preferred)
            tick_size: Manual override (if spec not provided)
            contract_size: Manual override
            fees_usd: Trading costs

        Returns:
            (lots, risk_usd)
        """
        # Extract values from spec OR kwargs
        if spec is not None:
            _tick_size = float(spec.tick_size)
            _contract_size = float(spec.contract_size)
        else:
            if tick_size is None or contract_size is None:
                raise ValueError("Must provide either 'spec' or 'tick_size + contract_size'")
            _tick_size = float(tick_size)
            _contract_size = float(contract_size)

        _fees = self.params.fees_usd if fees_usd is None else float(fees_usd)

        # Calculate risk in price units
        risk_pts = abs(float(entry) - float(stop))

        if risk_pts <= 0:
            raise ValueError("Invalid stop: risk_pts must be > 0")

        if risk_pts < float(self.params.min_risk_pts):
            raise ValueError(
                f"Risk too small: {risk_pts:.4f} < min_risk_pts={self.params.min_risk_pts:.4f}"
            )

        # Calculate position size
        risk_usd_target = float(balance) * (float(risk_pct) / 100.0)
        usd_per_point_per_lot = _contract_size

        lots = (risk_usd_target - _fees) / (risk_pts * usd_per_point_per_lot)
        lots = max(0.0, lots)

        # Validation
        if spec is not None:
            lots = spec.round_volume_down(lots)

        logger.debug(
            "SIZING: balance=%.2f risk_pct=%.4f target=%.2f risk_pts=%.4f -> lots=%.4f",
            balance,
            risk_pct,
            risk_usd_target,
            risk_pts,
            lots,
        )

        return lots, max(0.0, risk_usd_target - _fees)

    # Legacy alias for backward compatibility
    def calculate_lot_size(
        self, balance: float, spec: SymbolSpec, entry: float, stop: float
    ) -> float:
        """Legacy method - redirects to size_position"""
        lots, _ = self.size_position(
            balance=balance,
            entry=entry,
            stop=stop,
            spec=spec,
            risk_pct=1.0,  # Default 1% risk
        )
        return lots

================================================================================
FILE: execution/guardrails.py
================================================================================
from __future__ import annotations

import logging
from dataclasses import dataclass
from zoneinfo import ZoneInfo

import pandas as pd

from strategies.h2l2 import PlannedTrade

logger = logging.getLogger(__name__)


@dataclass(frozen=True)
class Guardrails:
    session_tz: str = "America/New_York"
    day_tz: str = "America/New_York"
    session_start: str = "09:30"
    session_end: str = "15:00"
    max_trades_per_day: int = 2
    one_trade_per_execute_ts: bool = True


def _parse_hhmm(s: str) -> tuple[int, int]:
    hh, mm = s.split(":")
    return int(hh), int(mm)


def _in_session(exec_ts_utc: pd.Timestamp, g: Guardrails) -> bool:
    try:
        tz = ZoneInfo(g.session_tz)
        ts_local = exec_ts_utc.tz_convert(tz)
    except Exception as e:
        logger.error("GUARDRAIL tz conversion failed: %s", e)
        return False

    sh, sm = _parse_hhmm(g.session_start)
    eh, em = _parse_hhmm(g.session_end)

    t = ts_local.time()
    start_time = t.replace(hour=sh, minute=sm, second=0, microsecond=0)
    end_time = t.replace(hour=eh, minute=em, second=0, microsecond=0)

    return start_time <= t <= end_time


def apply_guardrails(
    plans: list[PlannedTrade],
    g: Guardrails,
) -> tuple[list[PlannedTrade], list[tuple[PlannedTrade, str]]]:
    """
    Apply guardrails with minimal logging (no spam per rejected trade).
    """
    day_tz = ZoneInfo(g.day_tz)
    accepted: list[PlannedTrade] = []
    rejected: list[tuple[PlannedTrade, str]] = []

    trades_per_day: dict[pd.Timestamp, int] = {}
    used_exec_ts: set[pd.Timestamp] = set()

    # Count rejection reasons
    reject_counts = {"outside_session": 0, "naive_ts": 0, "duplicate_ts": 0, "max_per_day": 0}

    for t in plans:
        exec_ts = t.execute_ts

        if exec_ts.tzinfo is None:
            rejected.append((t, "naive_ts"))
            reject_counts["naive_ts"] += 1
            continue

        if not _in_session(exec_ts, g):
            rejected.append((t, "outside_session"))
            reject_counts["outside_session"] += 1
            continue

        if g.one_trade_per_execute_ts and exec_ts in used_exec_ts:
            rejected.append((t, "duplicate_ts"))
            reject_counts["duplicate_ts"] += 1
            continue

        day_key = exec_ts.tz_convert(day_tz).normalize()
        n = trades_per_day.get(day_key, 0)

        if n >= g.max_trades_per_day:
            rejected.append((t, "max_per_day"))
            reject_counts["max_per_day"] += 1
            continue

        trades_per_day[day_key] = n + 1
        used_exec_ts.add(exec_ts)
        accepted.append(t)

    # Summary logging only (no per-trade spam)
    logger.info(
        "Guardrails: accepted=%d rejected=%d (session=%d, max_day=%d, dupe=%d)",
        len(accepted),
        len(rejected),
        reject_counts["outside_session"],
        reject_counts["max_per_day"],
        reject_counts["duplicate_ts"],
    )

    return accepted, rejected

================================================================================
FILE: utils/mt5_client.py
================================================================================
from __future__ import annotations

import logging
from dataclasses import dataclass
from typing import Any

from utils.symbol_spec import SymbolSpec

logger = logging.getLogger(__name__)


class Mt5Error(RuntimeError):
    pass


@dataclass(frozen=True)
class Mt5ConnectionParams:
    login: int | None = None
    password: str | None = None
    server: str | None = None
    timeout_ms: int = 10_000


class Mt5Client:
    def __init__(self, mt5_module, params: Mt5ConnectionParams = Mt5ConnectionParams()):
        self._mt5 = mt5_module
        self._params = params
        self._initialized = False

    def initialize(self) -> bool:
        logger.info("Initializing MT5 connection...")
        kwargs: dict[str, Any] = {"timeout": self._params.timeout_ms}
        if self._params.login is not None:
            kwargs["login"] = self._params.login
            kwargs["password"] = self._params.password
            kwargs["server"] = self._params.server

        if not self._mt5.initialize(**kwargs):
            code, msg = self._safe_last_error()
            logger.error(f"MT5 initialize failed: {code} {msg}")
            return False

        self._initialized = True

        term = self._mt5.terminal_info()
        acc = self._mt5.account_info()
        t_name = term.name if term else "Unknown"
        a_login = acc.login if acc else "Unknown"
        logger.info(f"MT5 connected. Terminal={t_name}, Account={a_login}")
        return True

    def shutdown(self) -> None:
        if self._initialized:
            self._mt5.shutdown()
            self._initialized = False
            logger.info("MT5 connection shutdown.")

    def symbols_search(self, group: str = "") -> list[str]:
        self._require_init()
        symbols = self._mt5.symbols_get(group)
        if symbols is None:
            return []
        return [s.name for s in symbols]

    def ensure_selected(self, symbol: str) -> bool:
        self._require_init()
        if not self._mt5.symbol_select(symbol, True):
            logger.error(f"Failed to select symbol {symbol}")
            return False
        return True

    def get_symbol_specification(self, symbol: str) -> SymbolSpec | None:
        """
        Haalt specificaties op en retourneert een SymbolSpec object.
        """
        # 1. Haal de data op als dictionary via onze helper
        try:
            info_dict = self.symbol_info(symbol)
        except Mt5Error as e:
            logger.error(f"Error getting spec for {symbol}: {e}")
            return None

        # 2. Gebruik de factory methode in SymbolSpec om mapping fouten te voorkomen
        try:
            return SymbolSpec.from_symbol_info(info_dict)
        except Exception as e:
            logger.error(f"Failed to create SymbolSpec for {symbol}: {e}")
            return None

    def symbol_info(self, symbol: str) -> dict[str, Any]:
        """Wrapper rond mt5.symbol_info die altijd een dict teruggeeft."""
        self._require_init()

        # Zorg dat hij geselecteerd is
        if not self.ensure_selected(symbol):
            raise Mt5Error(f"Could not select {symbol}")

        info = self._mt5.symbol_info(symbol)
        if info is None:
            code, msg = self._safe_last_error()
            raise Mt5Error(f"symbol_info({symbol}) returned None: {code} {msg}")
        return symbol_info_to_dict(info)

    def _require_init(self) -> None:
        if not self._initialized:
            raise Mt5Error("MT5 not initialized. Call initialize() first.")

    def _safe_last_error(self) -> tuple:
        try:
            return self._mt5.last_error()
        except Exception:
            return -1, "unknown"


def symbol_info_to_dict(info_obj: Any) -> dict[str, Any]:
    """Zet MT5 object om naar dict."""
    if hasattr(info_obj, "_asdict"):
        return dict(info_obj._asdict())

    if hasattr(info_obj, "__dict__"):
        return dict(info_obj.__dict__)

    # Fallback velden (dit dekt de meeste mocks en echte objecten)
    known_fields = [
        "name",
        "digits",
        "point",
        "trade_contract_size",
        "spread",
        "trade_stops_level",
        "volume_min",
        "volume_max",
        "volume_step",
        "trade_tick_size",
        "trade_tick_value",
    ]
    return {k: getattr(info_obj, k) for k in known_fields if hasattr(info_obj, k)}

================================================================================
FILE: utils/mt5_data.py
================================================================================
from __future__ import annotations

import logging
from dataclasses import dataclass
from typing import Any

import pandas as pd

logger = logging.getLogger(__name__)


@dataclass(frozen=True)
class RatesRequest:
    """Request for MT5 rates via copy_rates_from_pos.

    Notes:
      - `pos` is the starting offset.
      - `count` is the number of bars to fetch.
    """

    symbol: str
    timeframe: int
    count: int
    pos: int = 0


def _validate_rates_request(req: RatesRequest) -> None:
    if not req.symbol or not isinstance(req.symbol, str):
        raise ValueError("symbol must be a non-empty string")
    if not isinstance(req.timeframe, int):
        raise ValueError("timeframe must be int")
    if not isinstance(req.count, int) or req.count <= 0:
        raise ValueError("count must be a positive int")
    if not isinstance(req.pos, int) or req.pos < 0:
        raise ValueError("pos must be a non-negative int")


def rates_to_df(rates: Any, *, require_ohlc: bool = True) -> pd.DataFrame:
    """Convert MT5 copy_rates_* output to a DataFrame.

    MT5 returns a numpy structured array with typical fields:
      time, open, high, low, close, tick_volume, spread, real_volume

    Behaviour:
      - Always keeps the raw integer `time` column if present.
      - Creates a UTC datetime index named `ts` from `time` (seconds) or `datetime`.
      - If OHLC is missing:
          * require_ohlc=True  -> raise ValueError
          * require_ohlc=False -> WARNING + return whatever columns exist (time-indexed)
    """
    if rates is None:
        return pd.DataFrame()

    df = pd.DataFrame(rates)
    if df.empty:
        return df

    cols = set(map(str, df.columns))

    # Build datetime index (ts) but do NOT drop the raw integer column(s).
    if "time" in cols:
        ts = pd.to_datetime(df["time"], unit="s", utc=True)
        df.insert(0, "ts", ts)
        df = df.set_index("ts")
    elif "datetime" in cols:
        ts = pd.to_datetime(df["datetime"], utc=True)
        df.insert(0, "ts", ts)
        df = df.set_index("ts")
    else:
        logger.error("MT5 rates dataframe missing time column. Columns=%s", list(df.columns))
        raise KeyError("MT5 rates missing 'time' column (or 'datetime'). See logs for columns.")

    required = ["open", "high", "low", "close"]
    missing = [c for c in required if c not in df.columns]
    if missing:
        if require_ohlc:
            logger.error("Missing OHLC columns: %s. Columns=%s", missing, list(df.columns))
            raise ValueError(f"Missing OHLC columns: {missing}")
        logger.warning(
            "OHLC columns not present in MT5 rates. Proceeding with time-index only. Columns=%s",
            list(df.columns),
        )

    # Data hygiene
    df = df.sort_index()
    df = df[~df.index.duplicated(keep="last")]
    return df


def fetch_rates(mt5, req: RatesRequest, *, require_ohlc: bool = True) -> pd.DataFrame:
    """Fetch rates in a single MT5 call."""
    _validate_rates_request(req)
    logger.info(
        "Fetching rates: symbol=%s tf=%s pos=%s count=%s",
        req.symbol,
        req.timeframe,
        req.pos,
        req.count,
    )

    rates = mt5.copy_rates_from_pos(req.symbol, req.timeframe, req.pos, req.count)
    if rates is None:
        code, msg = mt5.last_error()
        raise RuntimeError(f"copy_rates_from_pos failed: {code} {msg}")

    df = rates_to_df(rates, require_ohlc=require_ohlc)
    logger.info("Fetched %d bars for %s", len(df), req.symbol)
    return df


def fetch_rates_chunked(
    mt5,
    req: RatesRequest,
    *,
    chunk_size: int = 50_000,
    require_ohlc: bool = True,
) -> pd.DataFrame:
    """Fetch rates in chunks and stitch them together (no gaps / no duplicates).

    This exists because some brokers/terminals choke on very large `count` values.

    Stitching strategy:
      - Fetch sequential chunks from req.pos up to req.pos + req.count
      - Concatenate
      - De-dup on index (ts) keep last
    """
    _validate_rates_request(req)
    if not isinstance(chunk_size, int) or chunk_size <= 0:
        raise ValueError("chunk_size must be a positive int")

    if req.count <= chunk_size:
        logger.debug("Chunked fetch not needed (count=%s <= chunk_size=%s)", req.count, chunk_size)
        return fetch_rates(mt5, req, require_ohlc=require_ohlc)

    logger.info(
        "Chunked fetch start: symbol=%s tf=%s pos=%s count=%s chunk_size=%s",
        req.symbol,
        req.timeframe,
        req.pos,
        req.count,
        chunk_size,
    )

    remaining = req.count
    pos = req.pos
    chunks: list[pd.DataFrame] = []

    while remaining > 0:
        take = min(chunk_size, remaining)
        logger.debug("Fetching chunk: pos=%s count=%s (remaining=%s)", pos, take, remaining)

        rates = mt5.copy_rates_from_pos(req.symbol, req.timeframe, pos, take)
        if rates is None:
            code, msg = mt5.last_error()
            raise RuntimeError(f"copy_rates_from_pos failed: {code} {msg}")

        df_chunk = rates_to_df(rates, require_ohlc=require_ohlc)

        # If MT5 returned empty early, stop.
        if df_chunk.empty:
            logger.warning("Received empty chunk at pos=%s. Stopping early.", pos)
            break

        chunks.append(df_chunk)
        got = len(df_chunk)
        pos += got
        remaining -= got

        # Safety: avoid infinite loops if MT5 returns fewer rows than requested without progress
        if got == 0:
            logger.error("MT5 returned 0 rows for pos=%s take=%s; aborting.", pos, take)
            break

    if not chunks:
        return pd.DataFrame()

    out = pd.concat(chunks, axis=0, ignore_index=False)

    # Hygiene after stitching
    out = out.sort_index()
    out = out[~out.index.duplicated(keep="last")]

    logger.info("Chunked fetch done: got=%d bars for %s", len(out), req.symbol)
    return out

================================================================================
FILE: utils/symbol_spec.py
================================================================================
from __future__ import annotations

from dataclasses import dataclass
from typing import Any


@dataclass(frozen=True)
class SymbolSpec:
    name: str
    digits: int
    point: float
    tick_size: float
    tick_value: float
    contract_size: float  # Let op: hier heet het contract_size
    volume_min: float
    volume_step: float
    volume_max: float

    @property
    def usd_per_price_unit_per_lot(self) -> float:
        """
        USD value for a 1.0 price move per 1.0 lot.
        """
        if self.tick_size <= 0:
            # Prevent division by zero
            if self.tick_value > 0:
                return 0.0
            return 0.0
        return float(self.tick_value) / float(self.tick_size)

    def round_volume_down(self, vol: float) -> float:
        if vol <= 0:
            return 0.0
        # Epsilon voor floating point onnauwkeurigheden
        steps = int((vol + 1e-9) / self.volume_step)
        v = steps * self.volume_step
        if v < self.volume_min:
            return 0.0
        return min(v, self.volume_max)

    @staticmethod
    def from_symbol_info(info: dict[str, Any]) -> SymbolSpec:
        """
        Factory method: Vertaalt ruwe MT5 data (dict) naar een schoon SymbolSpec object.
        Dit voorkomt fouten met veldnamen in de rest van de applicatie.
        """
        return SymbolSpec(
            name=str(info["name"]),
            digits=int(info["digits"]),
            point=float(info["point"]),
            # MT5 heet het 'trade_tick_size', wij noemen het 'tick_size'
            tick_size=float(info.get("trade_tick_size", 0.0)),
            # MT5 heet het 'trade_tick_value', wij noemen het 'tick_value'
            tick_value=float(info.get("trade_tick_value", 0.0)),
            # MT5 heet het 'trade_contract_size', wij noemen het 'contract_size'
            contract_size=float(info.get("trade_contract_size", 1.0)),
            volume_min=float(info["volume_min"]),
            volume_step=float(info["volume_step"]),
            volume_max=float(info["volume_max"]),
        )

================================================================================
FILE: strategies/regime.py
================================================================================
# strategies/regime.py
"""
Market Regime Detection - FIXED VERSION
Correctly normalize price range by AVERAGE ATR over the same period
"""

from __future__ import annotations

from dataclasses import dataclass
from enum import Enum

import pandas as pd


class MarketRegime(str, Enum):
    """Market state classification"""

    TRENDING = "TRENDING"  # Clear directional move - TRADE
    CHOPPY = "CHOPPY"  # Range-bound, low volatility - SKIP
    UNKNOWN = "UNKNOWN"  # Not enough data


@dataclass(frozen=True)
class RegimeParams:
    """Configuration for regime detection"""

    atr_period: int = 14  # ATR calculation period
    range_period: int = 20  # Price range lookback
    chop_threshold: float = 2.5  # Range must be > (threshold Ã— AVG_ATR) to be trending
    min_bars: int = 50  # Minimum bars needed for valid detection


@dataclass(frozen=True)
class RegimeMetrics:
    """Diagnostics from regime detection"""

    regime: MarketRegime
    price_range: float  # High-Low over range_period
    avg_atr: float  # Average ATR over range_period (KEY FIX!)
    chop_ratio: float  # price_range / (chop_threshold Ã— avg_atr)
    bars_analyzed: int


def detect_regime_series(df: pd.DataFrame, params: RegimeParams) -> pd.Series:
    """
    VECTORIZED regime detection - CORRECTED VERSION

    KEY FIX: Compare price_range to AVERAGE ATR over the same period,
    not to single-bar ATR!

    Returns:
        Series with MarketRegime values (TRENDING/CHOPPY/UNKNOWN)
    """
    if df.empty:
        return pd.Series([], dtype="object", index=df.index)

    # Convert to float
    high = df["high"].astype(float)
    low = df["low"].astype(float)
    close = df["close"].astype(float)

    # Calculate ATR (bar range)
    bar_range = high - low
    atr = bar_range.rolling(params.atr_period, min_periods=params.atr_period).mean()

    # ðŸ”§ FIX: Average ATR over range_period (same window as price range!)
    avg_atr = atr.rolling(params.range_period, min_periods=params.range_period).mean()

    # Price range over range_period
    range_high = close.rolling(params.range_period, min_periods=params.range_period).max()
    range_low = close.rolling(params.range_period, min_periods=params.range_period).min()
    price_range = range_high - range_low

    # ðŸ”§ FIX: Chop ratio = price_range / (threshold Ã— avg_atr)
    # This normalizes: how many "average volatility units" did price move?
    threshold_range = params.chop_threshold * avg_atr
    chop_ratio = price_range / threshold_range

    # Classify regime
    regime = pd.Series([MarketRegime.UNKNOWN] * len(df), index=df.index, dtype="object")

    # Valid data mask (no NaN in calculations)
    valid_mask = ~(avg_atr.isna() | price_range.isna() | chop_ratio.isna())

    # Where valid AND chop_ratio < 1.0 â†’ CHOPPY (moved less than threshold)
    choppy_mask = valid_mask & (chop_ratio < 1.0)
    regime[choppy_mask] = MarketRegime.CHOPPY

    # Where valid AND chop_ratio >= 1.0 â†’ TRENDING (moved more than threshold)
    trending_mask = valid_mask & (chop_ratio >= 1.0)
    regime[trending_mask] = MarketRegime.TRENDING

    return regime


def detect_regime(df: pd.DataFrame, params: RegimeParams) -> tuple[MarketRegime, RegimeMetrics]:
    """
    Detect regime for LAST bar in dataframe (for main.py live trading)

    CORRECTED: Uses average ATR over range_period for proper normalization
    """
    min_required = params.atr_period + params.range_period  # 34 bars

    if len(df) < min_required:
        return MarketRegime.UNKNOWN, RegimeMetrics(
            regime=MarketRegime.UNKNOWN,
            price_range=0.0,
            avg_atr=0.0,
            chop_ratio=0.0,
            bars_analyzed=len(df),
        )

    # Convert to float
    high = df["high"].astype(float)
    low = df["low"].astype(float)
    close = df["close"].astype(float)

    # Calculate ATR
    bar_range = high - low
    atr = bar_range.rolling(params.atr_period).mean()

    # ðŸ”§ FIX: Average ATR over range_period
    avg_atr = atr.rolling(params.range_period).mean().iloc[-1]

    # Price range
    range_high = close.rolling(params.range_period).max().iloc[-1]
    range_low = close.rolling(params.range_period).min().iloc[-1]
    price_range = range_high - range_low

    # Check for NaN
    if pd.isna(avg_atr) or pd.isna(price_range) or avg_atr <= 0:
        return MarketRegime.UNKNOWN, RegimeMetrics(
            regime=MarketRegime.UNKNOWN,
            price_range=0.0,
            avg_atr=0.0,
            chop_ratio=0.0,
            bars_analyzed=len(df),
        )

    # ðŸ”§ FIX: Chop ratio with normalized threshold
    threshold_range = params.chop_threshold * avg_atr
    chop_ratio = price_range / threshold_range

    # Classify
    if chop_ratio < 1.0:
        regime = MarketRegime.CHOPPY
    else:
        regime = MarketRegime.TRENDING

    metrics = RegimeMetrics(
        regime=regime,
        price_range=price_range,
        avg_atr=avg_atr,
        chop_ratio=chop_ratio,
        bars_analyzed=len(df),
    )

    return regime, metrics


def should_trade_today(df: pd.DataFrame, params: RegimeParams) -> tuple[bool, str]:
    """
    Simple decision: should we trade today?

    Returns:
        (should_trade, reason) tuple
    """
    regime, metrics = detect_regime(df, params)

    if regime == MarketRegime.UNKNOWN:
        return (
            False,
            f"Not enough data ({metrics.bars_analyzed} bars, need {params.atr_period + params.range_period})",
        )

    if regime == MarketRegime.CHOPPY:
        return False, (
            f"Market is CHOPPY (range={metrics.price_range:.1f}, "
            f"ATR={metrics.avg_atr:.1f}, ratio={metrics.chop_ratio:.2f}). "
            "Waiting for trending conditions."
        )

    return True, f"Market is TRENDING (chop_ratio={metrics.chop_ratio:.2f} > 1.0). Safe to trade."


def filter_trading_days(
    daily_bars: list[pd.DataFrame], params: RegimeParams
) -> list[tuple[pd.DataFrame, bool, str]]:
    """
    Filter which days to trade based on regime

    Args:
        daily_bars: List of dataframes, one per day
        params: Regime detection config

    Returns:
        List of (df, should_trade, reason) tuples
    """
    results = []
    for df in daily_bars:
        trade, reason = should_trade_today(df, params)
        results.append((df, trade, reason))
    return results

================================================================================
FILE: strategies/context.py
================================================================================
# strategies/context.py
"""
Brooks Trend Filter - SIMPEL en EFFECTIEF
Regel: Trade met de trend. Trend = EMA richting + prijs positie.
"""

from __future__ import annotations

from dataclasses import dataclass
from enum import Enum

import pandas as pd


class Trend(str, Enum):
    BULL = "BULL"
    BEAR = "BEAR"


@dataclass(frozen=True)
class TrendParams:
    ema_period: int = 20
    ema_slope_bars: int = 5  # kijk 5 bars terug voor richting
    min_slope: float = 0.10  # minimaal 0.10 punten per 5 bars (filters range)
    # Brooks: "Trade met de trend. Maar alleen als trend DUIDELIJK is."


@dataclass(frozen=True)
class TrendMetrics:
    last_close: float
    last_ema: float
    ema_slope: float
    close_above_ema: bool


def infer_trend_m15(m15: pd.DataFrame, p: TrendParams) -> tuple[Trend | None, TrendMetrics]:
    """
    Brooks Trend Rule (simpel):
    - BULL: close > EMA EN EMA stijgend
    - BEAR: close < EMA EN EMA dalend
    - Geen extra filters. Period.
    """
    need = p.ema_period + p.ema_slope_bars
    if len(m15) < need:
        close = float(m15["close"].iloc[-1]) if len(m15) else 0.0
        metrics = TrendMetrics(close, close, 0.0, False)
        return None, metrics

    close = m15["close"].astype(float)
    ema = close.ewm(span=p.ema_period, adjust=False).mean()

    last_close = float(close.iloc[-1])
    last_ema = float(ema.iloc[-1])
    prev_ema = float(ema.iloc[-1 - p.ema_slope_bars])

    ema_slope = last_ema - prev_ema
    close_above_ema = last_close > last_ema

    metrics = TrendMetrics(
        last_close=last_close,
        last_ema=last_ema,
        ema_slope=ema_slope,
        close_above_ema=close_above_ema,
    )

    # Brooks regel: simpel maar met DUIDELIJKE trend requirement
    if close_above_ema and ema_slope >= p.min_slope:
        return Trend.BULL, metrics

    if not close_above_ema and ema_slope <= -p.min_slope:
        return Trend.BEAR, metrics

    return None, metrics


def infer_trend_m15_series(m15: pd.DataFrame, p: TrendParams) -> pd.Series:
    """
    Vectorized versie voor backtest runner (O(n) performance).
    Zelfde logica als infer_trend_m15, maar voor alle bars tegelijk.
    """
    if m15.empty:
        return pd.Series([], dtype="object", index=m15.index)

    close = m15["close"].astype(float)
    ema = close.ewm(span=p.ema_period, adjust=False).mean()

    ema_slope = ema - ema.shift(p.ema_slope_bars)
    close_above_ema = close > ema

    # Bull: close > EMA EN slope >= min_slope
    bull = close_above_ema & (ema_slope >= p.min_slope)

    # Bear: close < EMA EN slope <= -min_slope
    bear = (~close_above_ema) & (ema_slope <= -p.min_slope)

    out = pd.Series([None] * len(m15), index=m15.index, dtype="object")
    out[bull] = Trend.BULL
    out[bear] = Trend.BEAR

    # Warmup: eerste bars zijn unreliable
    need = p.ema_period + p.ema_slope_bars
    if len(out) >= need:
        out.iloc[: need - 1] = None

    return out

================================================================================
FILE: strategies/h2l2.py
================================================================================
# strategies/h2l2.py
"""
Brooks H2/L2 - SIMPEL zoals Brooks het bedoelde
Geen bar counting state machines. Alleen: pullback + rejection bar.
"""

from __future__ import annotations

import logging
from dataclasses import dataclass
from enum import Enum

import numpy as np
import pandas as pd

from utils.symbol_spec import SymbolSpec

logger = logging.getLogger(__name__)


class Side(str, Enum):
    LONG = "LONG"
    SHORT = "SHORT"


@dataclass(frozen=True)
class H2L2Params:
    """
    Brooks H2/L2 Parameters - KISS versie
    """

    # Swing detection: kijk N bars terug voor swing low/high
    pullback_bars: int = 3

    # Signal strength: close moet near high/low zijn
    signal_close_frac: float = 0.30  # binnen 30% van range

    # Risk management
    min_risk_price_units: float = 2.0  # minimaal 2pt risico (US500)
    stop_buffer: float = 1.0  # extra ruimte onder/boven swing

    # Legacy alias (voor oude tests)
    min_risk_points: float | None = None

    # Cooldown (optioneel, meestal 0)
    cooldown_bars: int = 0

    def __post_init__(self) -> None:
        if self.min_risk_points is not None:
            object.__setattr__(self, "min_risk_price_units", float(self.min_risk_points))


@dataclass(frozen=True)
class PlannedTrade:
    signal_ts: pd.Timestamp
    execute_ts: pd.Timestamp
    side: Side
    entry: float
    stop: float
    tp: float
    reason: str


def _require_ohlc(df: pd.DataFrame) -> None:
    needed = {"open", "high", "low", "close"}
    missing = needed - set(df.columns)
    if missing:
        raise ValueError(f"missing columns: {sorted(missing)}")
    if len(df.index) and df.index.tz is None:
        raise ValueError("index must be tz-aware (UTC recommended)")


def _normalize(df: pd.DataFrame) -> pd.DataFrame:
    if not df.index.is_monotonic_increasing:
        df = df.sort_index()
    if df.index.has_duplicates:
        df = df[~df.index.duplicated(keep="last")]
    return df


def _is_rejection_bar(o: float, h: float, low: float, c: float, side: Side, frac: float) -> bool:
    """
    Brooks rejection bar:
    - LONG: close near high + bullish body (c > o)
    - SHORT: close near low + bearish body (c < o)
    """
    bar_range = max(h - low, 1e-12)

    if side == Side.LONG:
        close_near_high = (h - c) <= frac * bar_range
        bullish = c > o
        return close_near_high and bullish
    else:  # SHORT
        close_near_low = (c - low) <= frac * bar_range
        bearish = c < o
        return close_near_low and bearish


def plan_h2l2_trades(
    m5: pd.DataFrame,
    trend: Side,
    spec: SymbolSpec,
    p: H2L2Params,
) -> list[PlannedTrade]:
    """
    Brooks H2/L2 - PURE implementatie:

    1. Detecteer swing low/high in laatste N bars (pullback_bars)
    2. Check of huidige bar rejection toont (close near extreme)
    3. Stop = swing +/- buffer
    4. Entry = volgende bar open (NEXT_OPEN)
    5. TP = 2R

    GEEN bar counting. GEEN attempt tracking. GEEN complex state.
    """
    _require_ohlc(m5)
    m5 = _normalize(m5)

    if len(m5) < p.pullback_bars + 2:
        return []

    trades: list[PlannedTrade] = []
    cooldown = 0

    for idx in range(p.pullback_bars, len(m5) - 1):
        if cooldown > 0:
            cooldown -= 1
            continue

        bar = m5.iloc[idx]
        next_bar = m5.iloc[idx + 1]

        o = float(bar["open"])
        h = float(bar["high"])
        low = float(bar["low"])
        c = float(bar["close"])

        entry = float(next_bar["open"])
        if not np.isfinite(entry):
            continue

        # Detecteer swing in lookback window (inclusief current bar)
        window = m5.iloc[idx - p.pullback_bars + 1 : idx + 1]
        swing_low = float(window["low"].min())
        swing_high = float(window["high"].max())

        # Skip doji's (geen range = geen rejection)
        if h - low < 0.01:
            continue

        # Check rejection bar
        if not _is_rejection_bar(o, h, low, c, trend, p.signal_close_frac):
            continue

        # Risk calculation
        if trend == Side.LONG:
            stop = swing_low - p.stop_buffer
            risk = entry - stop

            if risk < p.min_risk_price_units:
                continue

            tp = entry + 2.0 * risk

            trades.append(
                PlannedTrade(
                    signal_ts=bar.name,
                    execute_ts=next_bar.name,
                    side=Side.LONG,
                    entry=entry,
                    stop=stop,
                    tp=tp,
                    reason=f"H2 LONG: rejection after {p.pullback_bars}bar swing",
                )
            )

            logger.debug(
                "H2 LONG signal=%s exec=%s entry=%.2f stop=%.2f tp=%.2f risk=%.2f",
                bar.name,
                next_bar.name,
                entry,
                stop,
                tp,
                risk,
            )

            cooldown = p.cooldown_bars

        else:  # SHORT
            stop = swing_high + p.stop_buffer
            risk = stop - entry

            if risk < p.min_risk_price_units:
                continue

            tp = entry - 2.0 * risk

            trades.append(
                PlannedTrade(
                    signal_ts=bar.name,
                    execute_ts=next_bar.name,
                    side=Side.SHORT,
                    entry=entry,
                    stop=stop,
                    tp=tp,
                    reason=f"L2 SHORT: rejection after {p.pullback_bars}bar swing",
                )
            )

            logger.debug(
                "L2 SHORT signal=%s exec=%s entry=%.2f stop=%.2f tp=%.2f risk=%.2f",
                bar.name,
                next_bar.name,
                entry,
                stop,
                tp,
                risk,
            )

            cooldown = p.cooldown_bars

    return trades


def plan_next_open_trade(
    m5: pd.DataFrame,
    trend: Side,
    spec: SymbolSpec,
    p: H2L2Params,
    timeframe_minutes: int = 5,
    now_utc: pd.Timestamp | None = None,
) -> PlannedTrade | None:
    """
    NEXT_OPEN wrapper: vind laatste trade die execute op laatste/next bar.

    Backwards compatible met je tests, maar gebruikt nieuwe simpele logica.
    """
    _require_ohlc(m5)
    m5 = _normalize(m5)

    if len(m5) < p.pullback_bars + 2:
        return None

    # Plan alle trades
    all_trades = plan_h2l2_trades(m5, trend, spec, p)

    if not all_trades:
        return None

    last_ts = m5.index[-1]

    # Strategie 1: Execute op laatste bar (current bar scenario)
    last_exec = [t for t in all_trades if t.execute_ts == last_ts]
    if last_exec:
        return last_exec[-1]

    # Strategie 2: Signal op laatste bar, execute op synthetic next bar
    if now_utc is not None and now_utc.tzinfo is not None:
        age_sec = (now_utc - last_ts).total_seconds()
        if age_sec >= (timeframe_minutes * 60):
            # Closed bars scenario: check of laatste bar signal is
            last_signal = [t for t in all_trades if t.signal_ts == last_ts]
            if last_signal:
                # Update execute_ts naar synthetic next bar
                t = last_signal[-1]
                return PlannedTrade(
                    signal_ts=t.signal_ts,
                    execute_ts=last_ts + pd.Timedelta(minutes=timeframe_minutes),
                    side=t.side,
                    entry=t.entry,
                    stop=t.stop,
                    tp=t.tp,
                    reason=t.reason,
                )

    return None

================================================================================
FILE: config/strategies/us500_sniper.yaml
================================================================================
# Brooks Sniper Strategy - Quality over Quantity
# Optimized for FTMO challenge compliance
# 340-day backtest: +69.88R, Sharpe 1.806, MaxDD -13.32R

symbol: US500.cash

regime:
  enabled: true
  chop_threshold: 3.0  # Strict: skip choppy markets aggressively
  atr_period: 14
  range_period: 20

trend:
  ema_period: 15       # Faster response to trend changes
  min_slope: 0.10      # Lower threshold for trend detection

h2l2:
  pullback_bars: 3
  signal_close_frac: 0.35  # Stronger rejection requirement (vs 0.30)
  min_risk_price_units: 2.5  # Larger stops for breathing room
  stop_buffer: 1.0
  cooldown_bars: 20    # Avoid overtrading same trend segment

guardrails:
  session_tz: America/New_York
  day_tz: America/New_York
  session_start: "09:30"
  session_end: "16:00"
  max_trades_per_day: 1  # SNIPER: only best setup per day

risk:
  risk_pct: 1.0  # Can reduce to 0.5% for FTMO challenge

costs:
  per_trade_r: 0.04

# Performance Expectations (340-day backtest):
# - Net R: +69.88R (after costs)
# - Daily Sharpe: 1.806
# - Daily Sortino: 28.453
# - Max DD: -13.32R (-0.133% of 10k account)
# - Recovery Factor: 5.25
# - MAR Ratio: 3.89
# - Winrate: 41.77%
# - Avg R/trade: +0.2130R
# - Annual R est: +51.79R
